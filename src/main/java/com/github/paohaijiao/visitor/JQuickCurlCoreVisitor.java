/* * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * Copyright (c) [2025-2099] Martin (goudingcheng@gmail.com) */package com.github.paohaijiao.visitor;import com.github.paohaijiao.config.JQuickCurlConfig;import com.github.paohaijiao.enums.JProxryType;import com.github.paohaijiao.interceptor.JLoggingInterceptor;import com.github.paohaijiao.model.JFormParam;import com.github.paohaijiao.model.JHeaderParam;import com.github.paohaijiao.model.JProxryBean;import com.github.paohaijiao.param.JContext;import com.github.paohaijiao.parser.JQuickCurlBaseVisitor;import okhttp3.ConnectionPool;import okhttp3.Interceptor;import okhttp3.OkHttpClient;import okhttp3.ResponseBody;import org.apache.commons.lang3.StringUtils;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.InetSocketAddress;import java.net.Proxy;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;public class JQuickCurlCoreVisitor extends JQuickCurlBaseVisitor {    protected JContext context=new JContext();    protected JQuickCurlConfig config=JQuickCurlConfig.getInstance();    protected OkHttpClient client;    protected String requestType = null;    protected String method = null;    protected String url;    protected String data;    protected String ContentType="application/json";    protected List<JHeaderParam> headerList = new ArrayList<>();    protected String downLoadFileName;    protected String credential;    protected JProxryBean jproxry;    protected boolean ignoreSsl = false;    protected List<JFormParam> upLoadFileList = new ArrayList<>();    public  OkHttpClient getOkHttpClient(){        if(ignoreSsl){            return getIgNoreSSlOkHttpClient();        }else{            return getCommonOkHttpClient();        }    }    public OkHttpClient getCommonOkHttpClient(){        OkHttpClient baseClient = new OkHttpClient.Builder()                .addInterceptor(new JLoggingInterceptor())                .build();        Proxy proxy =null;        if (jproxry != null) {            proxy = new Proxy(JProxryType.HTTP.getCode().equals(jproxry.getType().getCode())?                    Proxy.Type.HTTP:Proxy.Type.SOCKS,                    new InetSocketAddress(jproxry.getHost(),jproxry.getPort()));        }        OkHttpClient.Builder builder = baseClient.newBuilder();        builder.connectTimeout(config.getConnectTimeout(), config.getTimeUnit());        builder.readTimeout(config.getReadTimeout(), config.getTimeUnit());        builder.writeTimeout(config.getWriteTimeout(), config.getTimeUnit());        builder.callTimeout(config.getCallTimeout(), config.getTimeUnit());        builder.connectionPool(new ConnectionPool(config.getMaxIdleConnections(), config.getKeepAliveDuration(), config.getTimeUnit()));        builder.retryOnConnectionFailure(config.getRetryOnConnectionFailure());        builder.followRedirects(config.getFollowRedirects());        builder.followSslRedirects(config.getFollowSslRedirects());        builder.addInterceptor(new JLoggingInterceptor());        for (Interceptor interceptor : config.getInterceptors()) {            builder.addInterceptor(interceptor);        }        if (proxy != null) {            builder.proxy(proxy);            return builder.build();        }else{            return builder.build();        }    }    public OkHttpClient getIgNoreSSlOkHttpClient(){        OkHttpClient baseClient = new OkHttpClient.Builder()                .addInterceptor(new JLoggingInterceptor())                .build();        try {            final TrustManager[] trustAllCerts = getTrustManager();            final SSLContext sslContext = SSLContext.getInstance("SSL");            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());            Proxy proxy =null;            if (jproxry != null) {                proxy = new Proxy(JProxryType.HTTP.getCode().equals(jproxry.getType().getCode())?                        Proxy.Type.HTTP:Proxy.Type.SOCKS,                        new InetSocketAddress(jproxry.getHost(),jproxry.getPort()));            }            OkHttpClient.Builder builder = baseClient.newBuilder();            builder.connectTimeout(config.getConnectTimeout(), config.getTimeUnit());            builder.readTimeout(config.getReadTimeout(), config.getTimeUnit());            builder.writeTimeout(config.getWriteTimeout(), config.getTimeUnit());            builder.callTimeout(config.getCallTimeout(), config.getTimeUnit());            builder.connectionPool(new ConnectionPool(config.getMaxIdleConnections(), config.getKeepAliveDuration(), config.getTimeUnit()));            builder.retryOnConnectionFailure(config.getRetryOnConnectionFailure());            builder.followRedirects(config.getFollowRedirects());            builder.followSslRedirects(config.getFollowSslRedirects());            builder.addInterceptor(new JLoggingInterceptor());            if (proxy != null) {                builder.proxy(proxy);                return builder.build();            }else{                return builder.build();            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public static TrustManager[] getTrustManager() {        try {            final TrustManager[] trustAllCerts = new TrustManager[] {                    new X509TrustManager() {                        @Override                        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {                        }                        @Override                        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {                        }                        @Override                        public X509Certificate[] getAcceptedIssuers() {                            return new X509Certificate[]{};                        }                    }            };            return trustAllCerts;        } catch (Exception e) {            throw new RuntimeException(e);        }    }    protected String trimFileName(String fileName) {        if(StringUtils.isNotEmpty(fileName)){            return fileName.replaceAll("@", "");        }else {            return fileName;        }    }    protected byte[] downLoadFile(ResponseBody responseBody) {        try {            InputStream inputStream = responseBody.byteStream();            FileOutputStream outputStream = new FileOutputStream(downLoadFileName) ;            byte[] buffer = new byte[4096];            int bytesRead;            while((bytesRead =inputStream.read(buffer))!=-1) {                outputStream.write(buffer, 0, bytesRead);            }            return buffer;        } catch(IOException e){            e.printStackTrace();        }        return null;    }}